<!DOCTYPE html>
<html>
<body>
<h1>Freestanding Proposal</h1>
Document number: D0829R1<br/>
Date: 2017-10-14<br/>
Reply-to: Ben Craig &lt;ben dot craig at gmail dot com&gt;<br/>
Audience: SG14, Library Evolution Working Group
<h1>I. Introduction</h1>
<p>
The current definition of the freestanding implementation is not very useful.  Here is the current high level definition from [intro.compliance]:
<blockquote>7 Two kinds of implementations are defined: a hosted implementation and a freestanding implementation. For a
hosted implementation, this document defines the set of available libraries. A freestanding implementation is
one in which execution may take place without the benefit of an operating system, and has an implementation defined
set of libraries that includes certain language-support libraries (20.5.1.3).</blockquote>
<p>
The main people served by the current freestanding definition are people writing their own hosted C++ standard library to sit atop the compiler author's freestanding implementation (i.e. the STLport use case).  The freestanding portions contain all the functions and types known to the compiler that can't easily be authored in a cross-compiler manner.
</p><p>
The current set of freestanding libraries provides too little to kernel and embedded programmers.  Why should a systems programmer need to rewrite <code>std::sort()</code> or <code>std::memcpy()</code>?
</p><p>
I propose we provide the (nearly) maximal subset of the library that does not require an OS or space overhead.  In order to continue supporting the "layered" C++ standard library users, we will continue to provide the (nearly) minimal subset of the library needed to support all the language features, even if these features have space overhead.  Freestanding library features requiring OS support will be removed.  Language features requiring space overhead or OS support will remain intact.
</p>
<h1>II. Motivation</h1>
<p>
Systems programmers want to sort things.  They want to use move semantics.  They may even want to bundle the arguments of a variadic template function into a <code>std::tuple</code>.  These are all reasonable things to do on a system with no operating system and kilobytes of storage.  The C++ standard even has reasonable specifications for these operations in the context of a tiny, OS-less system.  However, systems programmers must currently rely on either hand-rolled code or implementer extensions in order to get these facilities.
</p><p>
Systems programmers don't have a guide as to what C++ library facilities will work without trying them.  The standard says <code>atomic_load</code> will work; <code>memcpy</code> will probably work; but will <code>stable_sort</code>?  Standardizing the subset of implementable C++ that is usable in a freestanding environment would provide clarity here, and help to educate systems programmers.
</p>
<h1>III. Current State</h1>
<p>
There were some presentations at recent CppCons where others made a more full featured C++ work in the Linux and Windows kernels [Quinn2016] [Baker2017].  In both of these cases, C++ was being used in a sandboxed / pseudo-virtualized way.  C++ code (with exceptions and RTTI) was being run in the kernel context, but very few calls were made between the C++ code and the operating system kernel.  The C++ code was in a guest operating system.  This proposal should make it reasonable to have C++ code interact closely with the internals of a host operating system, perhaps in the context of a driver.
</p><p>
The Microsoft Windows kernel and Apple Mac OSX kernel both currently support limited, non-compliant subsets of C++ for driver writers.  The Linux kernel does not support C++ officially, though with a fair amount of work on the part of the driver developer, C++ can be made to work.  Drivers written in C++ are highly unlikely to be accepted in the upstream Linux source repositories.
</p><p>
IncludeOS [Bratterud2017] is an OS primarily intended for running in VMs, though some bare metal support has been tested.  One might expect such a project to use a freestanding implementation as a base, but instead, it starts with a hosted implmentation of C++ and drops support for the impractical parts (threads and filestreams in particular).
</p><p>
Out of libstdc++, libc++, and Microsoft's Visual Studio STL, only libstdc++ has any relevant mention of "freestanding" or "hosted".  In practice, users take a hosted implementation of C++ and use it as-is in situations where it was never intended.  This means that all the headers tend to be available, but only a few of the headers actually work.  Many of the headers that work aren't marked freestanding.  Some headers have parts that could work, except they are mixed with other parts that won't work.  For example, <code>iterator_traits</code> in <code>&lt;iterator&gt;</code> is fine, but the implementation details of the stream iterators cause build errors with the <code>/kernel</code> flag in Microsoft Visual Studio 2017.
</p>
<h1>IV. Scope</h1>
<p>
The current scope of this proposal is limited to the freestanding standard library available to systems and embedded programming.
</p><p>
This paper is currently concerned with the divisions of headers and library functions as they were in C++17.  <a href="http://wg21.link/p0581">"Standard Library Modules" (P0581)</a> discusses how the library will be split up in a post-modules world.  This paper may influence the direction of P0581, but this paper won't make any modules recommendations.
</p><p>
I could see the scope increasing to the standard library availability on GPUs.  It also occurs to me that the list of standard library functions suitable for a freestanding implementation is likely a large subset of the list of functions that could be marked <code>constexpr</code>, and conditionally <code>noexcept</code>.  This paper will not attempt to address those items though.
</p><p>
<h1>V. Impact on the standard</h1>
<p>
Rather than list all of the facilities available to a freestanding implementation in one place, as is currently done in [compliance], the standard would tag each header, class, or function that is available in a freestanding implementation.  I expect this to be a large number of small edits, but the edits would have easy to understand ramifications throughout the standard.
</p><p>
There is precedent for this kind of tagging in other specification documents.  The ECMAScript Language Specification has optional support for ECMA-402 (internationalization).  The impact of ECMA-402 is called out explicitly in several places.  POSIX tags functions as supported in base, XSI, or in one of many option groups.
</p><p>
There were some conversations in the 2017 Albuquerque meeting around adding another class of conforming implementation.  I believe that such an action would be a mistake.  Maintaining two classifications is difficult enough as is, and freestanding is often neglected.  Adding another classification would magnify these problems.  I also feel that the freestanding classification should be removed if no action is taken to make it more useful.
</p>
<h3>Naming alternatives</h3>
<p>
There was some desire to come up with a new name for "freestanding" in the 2017 Albuquerque meeting.  This new name could better express the intended audience of such an implementation.  My current recommendation will be to keep the name "freestanding", but I will suggest some alternatives just the same.
</p>
<ul>
<li>barebones</li>
<li>basic</li>
<li>embedded</li>
<li>freestanding</li>
<li>kernel</li>
<li>minimal</li>
<li>OS-free</li>
<li>OS-less</li>
<li>skeleton</li>
<li>standalone</li>
<li>stripped</li>
<li>system-free</li>
<li>unsupported</li>
</ul>

<h1>VI. Impact on implementations</h1>
<p>
C++ standard library headers will likely need to add preprocessor feature toggles to portions of headers that would emit warning or errors in freestanding mode.  The precision and timeliness (compile time vs. link time) of errors remains a quality-of-implementation detail.
</p><p>
A minimal freestanding C11 standard library will not be sufficient to provide the C portions of the C++ standard library.  <code>std::char_traits</code> and many of the function specializations in <code>&lt;algorithm&gt;</code> are implemented in terms of non-freestanding C functions.  In practice, most C libraries are not minimal freestanding C11 libraries.  The optimized versions of the <code>&lt;cstring&gt;</code> and <code>&lt;cwchar&gt;</code> functions will typically be the same for both hosted and freestanding environments.
</p>
<h1>VII. Design decisions</h1>
<p>
Even more so than for a hosted implementation, systems and embedded programmers do not want to pay for what they don't use.  As a consequence, I am avoiding all features that require global storage, even if that storage is immutable.
</p><p>
Note that these are not concerns revolving around execution time performance.  These are generally concerns about space overhead and correctness.
</p>
<ul>
<li>Exceptions either require external jump tables or extra bookkeeping instructions, consuming program storage space.  In the Itanium ABI, throwing an exception requires a heap allocation.  In the Microsoft ABI, re-throwing an exception will consume surprisingly large amounts of stack space.  Program storage space, heap space, and stack space are typically scarce resources in embedded development. In most environments with dynamic libraries (including most kernels), the OS and unwinder need to do extra work to figure out which library's exception table needs to be referenced.</li>
<li>RTTI requires extra data in vtables and extra classes that are difficult to optimize away, consuming program storage space.</li>
<li>The heap is a big set of global state.  In addition, heap exhaustion is typically expressed via exception.  Some embedded systems don't even have a heap.</li>
<li>Thread-local storage requires extra code in the operating system for support.  In addition, if one thread uses thread local storage, that cost is imposed on other threads.</li>
<li>Many embedded systems don't have floating point hardware, and software emulated floating point can drag in large runtimes that are difficult to optimize away.  Also, most operating systems speed up system calls by not saving and restoring floating point state.  That means that kernel uses of floating point operations require extra care to avoid corrupting user state.</li>
<li>Some functions require global or thread-local storage.  These functions have been omitted or removed from the freestanding library.  Examples are the locale aware functions and the C random number functions.</li>
</ul>
<p>
For the <code>&lt;algorithms&gt;</code> header, we would only be able to support sequential execution of parallel algorithms.  Since this adds little value, the execution policy overloads will be omitted.
</p><p>
This proposal doesn't remove problematic features from the language, but it does make it so that the bulk of the freestanding standard library doesn't require those features.  Users that disable the problematic features (as is existing practice) will still have portable portions of the standard library at their disposal.
</p>
<h1>VIII. Technical Specifications</h1>
<h2>Facilities no longer required for freestanding implementations</h2>
Usages of the operating system
<ul>
<li><code>&lt;new&gt; hardware_destructive_interference_size</code></li>
<li><code>&lt;new&gt; hardware_constructive_interference_size</code></li>
</ul>

<h2>Facilities newly required for freestanding implementations</h2>
Portions of <code>&lt;cstdlib&gt;</code>
<ul>
<code><li>div_t</li>
<li>ldiv_t</li>
<li>lldiv_t</li>
<li>EXIT_FAILURE</li>
<li>EXIT_SUCCESS</li>
<li>_Exit</li>
<li>atoi</li>
<li>atol</li>
<li>atoll</li>
<li>bsearch</li>
<li>qsort</li>
<li>abs(int)</li>
<li>abs(long int)</li>
<li>abs(long long int)</li>
<li>labs</li>
<li>div</li>
<li>ldiv</li>
<li>lldiv</li></code>
</ul>
<p>
All the error <code>#defines</code> in <code>&lt;cerrno&gt;</code>, but not <code>errno</code>.
</p><p>
The <code>errc</code> enum from <code>&lt;system_error&gt;</code>.
</p><p>
All of <code>&lt;utility&gt;</code> and <code>&lt;tuple&gt;</code>.
</p><p>
Portions of <code>&lt;memory&gt;</code>.
</p>
<ul>
<li><code>pointer_traits</code></li>
<li><code>align</code></li>
<li>23.10.10, specialized algorithms</li>
</ul>
<p>
Most of <code>&lt;functional&gt;</code>.  <b>Omit</b> the following.
<ul>
<li>23.14.13, polymorphic function wrappers (i.e. <code>std::function</code> and friends).</li>
<li>23.14.14.2, <code>boyer_moore_searcher</code></li>
<li>23.14.14.3, <code>boyer_moore_horspool_searcher</code></li>
</ul>
</p><p>
All of <code>&lt;ratio&gt;</code>.
</p><p>
Most of <code>&lt;chrono&gt;</code>.  <b>Omit</b> 23.17.7, Clocks.
</p><p>
Portions of <code>&lt;charconv&gt;</code>.
</p>
<ul>
<li><code>to_chars_result</code></li>
<li><code>from_chars_result</code></li>
<li><code>to_chars</code>(integral)</li>
<li><code>from_chars</code>(integral)</li>
</ul>
<p>
The <code>char_traits</code> class from <code>&lt;string&gt;</code>.
</p><p>
Portions of <code>&lt;cstring&gt;</code>.
<ul>
<code><li>memcpy</li>
<li>memmove</li>
<li>strcpy</li>
<li>strncpy</li>
<li>strcat</li>
<li>strncat</li>
<li>memcmp</li>
<li>strcmp</li>
<li>strncmp</li>
<li>memchr</li>
<li>strchr</li>
<li>strcspn</li>
<li>strpbrk</li>
<li>strrchr</li>
<li>strspn</li>
<li>strstr</li>
<li>memset</li>
<li>strlen</li>
</code></ul>
Portions of <code>&lt;cwchar&gt;</code>.
<ul>
<code><li>wcscpy</li>
<li>wcsncpy</li>
<li>wmemcpy</li>
<li>wmemmove</li>
<li>wcscat</li>
<li>wcsncat</li>
<li>wcscmp</li>
<li>wcsncmp</li>
<li>wmemcmp</li>
<li>wcschr</li>
<li>wcscspn</li>
<li>wcxpbrk</li>
<li>wcsrchr</li>
<li>wcsspn</li>
<li>wcsstr</li>
<li>wcstok</li>
<li>wmemchr</li>
<li>wcslen</li>
<li>wmemset</li>
</code></ul>
<p>
All of <code>&lt;iterator&gt;</code> except for the stream iterators and the insert iterators.
</p><p>
Most of <code>&lt;algorithm&gt;</code> and <code>&lt;numeric&gt;</code>.  The ExecutionPolicy overloads will not be included.  The following functions will be <b>omitted</b> due to the usage of temporary buffers:
</p>
<ul>
<code><li>stable_sort</li>
<li>stable_partition</li>
<li>inplace_merge</li>
</code></ul>
<p>
Portions of <code>&lt;random&gt;</code>.  The following portions will be <b>omitted</b>:
</p>
<ul>
<code><li>random_device</li>
<li>uniform_real_distribution</li>
<li>exponential_distribution</li>
<li>gamma_distribution</li>
<li>weibull_distribution</li>
<li>extreme_value_distribution</li>
<li>normal_distribution</li>
<li>lognormal_distribution</li>
<li>chi_squared_distribution</li>
<li>cauchy_distribution</li>
<li>fisher_f_distribution</li>
<li>student_t_distribution</li>
<li>piecewise_constant_distribution</li>
<li>piecewise_linear_distribution</li>
</code></ul>
A small portion of <code>&lt;cmath&gt;</code> will be present.
<ul>
<code><li>abs(int)</li>
<li>abs(long int)</li>
<li>abs(long long int)</li>
</code></ul>
A portion of <code>&lt;cinttypes&gt;</code> will be present.
<ul>
<code><li>imaxabs</li>
<li>imaxdiv</li>
<li>abs(intmax_t)</li>
<li>div(intmax_t, intmax_t)</li>
</code></ul>
<h2>Notable omissions</h2>
<p>
<code>bitset</code> is not included because many of its functions throw as part of a range check.
</p><p>
<code>errno</code> is not included as it is global state.  In addition, errno is best implemented as a thread_local variable.
</p><p>
<code>error_code</code>, <code>error_condition</code>, and <code>error_condition</code> all have <code>string</code> in the interface.
</p><p>
Many string functions (<code>strtol</code> and family) rely on <code>errno</code>.
</p><p>
<code>string_view</code> and <code>array</code> have methods that can throw exceptions.
</p><p>
<code>assert</code> is not included as it requires a stderror stream.
</p><p>
<code>&lt;variant&gt;</code> and <code>&lt;optional&gt;</code> could work in a freestanding environment if their interfaces didn't rely on exceptions.
</p><p>
<code>&lt;cctype&gt;</code> and <code>&lt;cwctype&gt;</code> rely heavily on global locale data.
</p><p>
<code>unique_ptr</code> is generally used for heap management, but is occasionally used as a makeshift RAII object for other resources.  The use of the <code>default_delete</code> class in the template parameters is what dooms this class.  In the future, <a href="http://wg21.link/p0052"><code>unique_resource</code> and <code>scope_exit</code></a> may satisfy the non-deleting use cases that <code>unique_ptr</code> currently fills.
</p>
<h2>Potential removals</h2>
Here are some things that I am currently requiring, but could be convinced to remove.
<ul><li><code>&lt;cwchar&gt;</code></li></ul>
These functions are implementable, but infrequently used for systems programming.  They do not exist in freestanding C11 implementations.
<ul><li><code>&lt;random&gt;</code></li></ul>
I am not confident that the remaining distributions are implementable without using floating point.  These classes also carry a high implementer burden.
<h2>Potential additions</h2>
Here are some things that I am not currently requiring, but could be convinced to add.
<ul><li><code>complex&lt;integer&gt;</code></li></ul>
I currently omit the <code>complex</code> class entirely, but in theory, the integer version of <code>complex</code> are fine.  I am unsure how many of the associated functions are implementable without floating point access though.  I do not believe that <code>complex</code> for integer types is a widely used class though.
<ul><li>Floating point support</li></ul>
Perhaps we don't worry about library portability in all cases.  Just because kernel modes can't easily use floating point doesn't mean that we should deny floating point to the embedded space.  Do note that most of <code>&lt;cmath&gt;</code> has a dependency on <code>errno</code>.
<ul><li><code>errno</code> and string functions like <code>strtol</code></li></ul>
While <code>errno</code> is global data, it isn't much global data.  Thread safety is a concern for those platforms that have threading, but don't have thread local storage.
<ul><li><code>unique_ptr</code></li></ul>
There are uses for <code>unique_ptr</code> that don't require the heap, and can be made to work.    Since we still require new and delete to exist, <code>default_delete</code> shouldn't have any problems compiling.

<h1>IX. Acknowledgements</h1>
<p>
Thanks to Brandon Streiff, Joshua Cannon, Phil Hindman, and Irwan Djajadi for reviewing this proposal.
</p><p>
Similar work was done in the C++11 timeframe by Lawrence Crowl and Alberto Ganesh Barbati in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3256.html">N3256</a>.
</p><p>
CppCon talks on getting C++ support in various unusual environments:
</p><p>
[Baker2017] CppCon 2017: Billy Baker "Almost Unlimited Modern C++ in Kernel-Mode Applications"
</p><p>
[Quinn2016] CppCon 2016: Rian Quinn "Making C++ and the STL Work in the Linux / Windows Kernels"
</p><p>
[Bratterud2017] CppCon 2017: Alfred Bratterud "Deconstructing the OS: The devil's In the side effects"
</p>
</body>
</html>
