<!DOCTYPE html>
<html>
<body>
<h1>Freestanding Proposal</h1>
Document number: D0829R1<br/>
Date: 2017-10-14<br/>
Reply-to: Ben Craig &lt;ben dot craig at gmail dot com&gt;<br/>
Audience: SG14, Library Evolution Working Group
<h1>I. Introduction</h1>
<p>
The current definition of the freestanding implementation is not very useful.  Here is the current high level definition from [intro.compliance]:
<blockquote>7 Two kinds of implementations are defined: a hosted implementation and a freestanding implementation. For a
hosted implementation, this document defines the set of available libraries. A freestanding implementation is
one in which execution may take place without the benefit of an operating system, and has an implementation defined
set of libraries that includes certain language-support libraries (20.5.1.3).</blockquote>
The current set of freestanding libraries provides too little to kernel and embedded programmers.  Why should a systems programmer need to rewrite <code>std::sort()</code> or <code>std::memcpy()</code>?
</p><p>
Rather than provide the (nearly) minimal subset of the library needed to support all the language features, I propose we also provide the (nearly) maximal subset of the library that does not require an OS or space overhead.
</p>
<h1>II. Motivation</h1>
<p>
Systems programmers want to sort things.  They want to use move semantics.  They may even want to bundle the arguments of a variadic template function into a tuple.  These are all reasonable things to do on a system with no operating system and kilobytes of storage.  The C++ standard even has reasonable specifications for these operations in the context of a tiny, OS-less system.  However, systems programmers must currently rely on either hand-rolled code or implementer extensions in order to get these facilities.
</p><p>
Systems programmers don't have a guide as to what C++ library facilities will work without trying them.  The standard says <code>atomic_load</code> will work; <code>memcpy</code> will probably work; but will <code>stable_sort</code>?  Standardizing the subset of implementable C++ that is usable in a freestanding environment would provide clarity here, and help to educate systems programmers.
</p>
<h1>III. Current State</h1>
<p>
The current state of freestanding implementations is rather sad.  Of the "big three" standard libraries (libstdc++, libc++, and Microsoft's Visual Studio STL), only libstdc++ has any relevant mention of "freestanding" or "hosted".  In practice, users take a hosted implementation of C++ and use it as-is in situations where it was never intended.  This means that all the headers tend to be available, but only a few of the headers actually work.  The parts that "should" work in a freestanding system, as specified by the C++17 standard, don't always work, while parts that aren't specified work fine.  For example, just creating an instance of <code>std::bad_alloc</code> (without even throwing it!) causes linker errors in the Windows kernel with Visual Studio 2017, and it causes linker errors on a bare metal ARMv5 target with gcc 4.8.
</p>
<pre>Visual Studio 2017, x64 Kernel
cppCode.obj : error LNK2019: unresolved external symbol "void __cdecl operator delete(void *,unsigned __int64)" (??3@YAXPEAX_K@Z) referenced in function "public: virtual void * __cdecl std::bad_alloc::`scalar deleting destructor'(unsigned int)" (??_Gbad_alloc@std@@UEAAPEAXI@Z)
cppCode.obj : error LNK2019: unresolved external symbol __std_exception_destroy referenced in function "public: virtual __cdecl std::exception::~exception(void)" (??1exception@std@@UEAA@XZ)

gcc-4.8, ARMv5 bare metal
libgcc.a(unwind-arm.o): In function `get_eit_entry':
   unwind-arm.c:(.text+0x20c): undefined reference to `__exidx_end'
   unwind-arm.c:(.text+0x210): undefined reference to `__exidx_start'
libc.a(lib_a-abort.o): In function `abort':
   abort.c:(.text+0x10): undefined reference to `_exit'
libc.a(lib_a-sbrkr.o): In function `_sbrk_r':
   sbrkr.c:(.text+0x18): undefined reference to `_sbrk'
libc.a(lib_a-signalr.o): In function `_kill_r':
   signalr.c:(.text+0x1c): undefined reference to `_kill'
libc.a(lib_a-signalr.o): In function `_getpid_r':
   signalr.c:(.text+0x44): undefined reference to `_getpid'
libc.a(lib_a-writer.o): In function `_write_r':
   writer.c:(.text+0x20): undefined reference to `_write'
libc.a(lib_a-closer.o): In function `_close_r':
   closer.c:(.text+0x18): undefined reference to `_close'
libc.a(lib_a-fstatr.o): In function `_fstat_r':
   fstatr.c:(.text+0x1c): undefined reference to `_fstat'
libc.a(lib_a-isattyr.o): In function `_isatty_r':
   isattyr.c:(.text+0x18): undefined reference to `_isatty'
libc.a(lib_a-lseekr.o): In function `_lseek_r':
   lseekr.c:(.text+0x20): undefined reference to `_lseek'
libc.a(lib_a-readr.o): In function `_read_r':
   readr.c:(.text+0x20): undefined reference to `_read'</pre>
<p>
<code>std::sort</code> works just fine on both targets though.
</p><p>
The Microsoft Windows kernel and Apple Mac OSX kernel both currently support limited, non-compliant subsets of C++ for driver writers.  The Linux kernel does not support C++ officially, though with a fair amount of work on the part of the driver developer, C++ can be made to work.  Drivers written in C++ are highly unlikely to be accepted in the upstream Linux source repositories.
</p><p>
There were some presentations at recent CppCons where others made a more full featured C++ work in the Linux and Windows kernels [Quinn2016] [Baker2017].  In both of these cases, C++ was being used in a sandboxed / pseudo-virtualized way.  C++ code (with exceptions and RTTI) was being run in the kernel context, but very few calls were made between the C++ code and the operating system kernel.  The C++ code was in a guest operating system.  This proposal should make it reasonable to have C++ code interact closely with the internals of a host operating system, perhaps in the context of a driver.
</p><p>
IncludeOS [Bratterud2017] is an OS primarily intended for running in VMs, though some bare metal support has been tested.  One might expect such a project to use a freestanding implementation as a base, but instead, it starts with a hosted implmentation of C++ and drops support for the impractical parts (threads and filestreams in particular).
</p>
<h1>IV. Scope</h1>
<p>
The current scope of this proposal is limited to the freestanding standard library available to systems and embedded programming.
</p><p>
This paper is currently concerned with the divisions of headers and library functions as they were in C++17.  <a href="http://wg21.link/p0581">"Standard Library Modules" (P0581)</a> discusses how the library will be split up in a post-modules world.  This paper may influence the direction of P0581, but this paper won't make any modules recommendations.
</p><p>
I could see the scope increasing to the standard library availability on GPUs.  It also occurs to me that the list of standard library functions suitable for a freestanding implementation is likely a large subset of the list of functions that could be marked constexpr, and conditionally noexcept.  This paper will not attempt to address those items though.
</p><p>
<h1>V. Impact on the standard</h1>
<p>
Rather than list all of the facilities available to a freestanding implementation in one place, as is currently done in [compliance], the standard would tag each header, class, or function that is available in a freestanding implementation.  I expect this to be a large number of small edits, but the edits would have easy to understand ramifications throughout the standard.
</p><p>
There is precedent for this kind of tagging in other specification documents.  The ECMAScript Language Specification has optional support for ECMA-402 (internationalization).  The impact of ECMA-402 is called out explicitly in several places.  POSIX tags functions as supported in base, XSI, or in one of many option groups.
</p>
<h1>VI. Impact on implementations</h1>
<p>
C++ standard library headers will likely need to add preprocessor feature toggles to portions of headers that would emit warning or errors in freestanding mode.  The precision and timeliness (compile time vs. link time) of errors remains a quality-of-implementation detail.
</p><p>
A minimal freestanding C11 standard library will not be sufficient to provide the C portions of the C++ standard library.  <code>std::char_traits</code> and many of the function specializations in <code>&lt;algorithm&gt;</code> are implemented in terms of non-freestanding C functions.  In practice, most C libraries are not minimal freestanding C11 libraries.  The optimized versions of the <code>&lt;cstring&gt;</code> and <code>&lt;cwchar&gt;</code> functions will typically be the same for both hosted and freestanding environments.
</p>
<h1>VII. Design decisions</h1>
<p>
Even more so than for a hosted implementation, systems and embedded programmers do not want to pay for what they don't use.  As a consequence, I am avoiding all features that require global storage, even if that storage is immutable.
</p><p>
Note that these are not concerns revolving around execution time performance.  These are generally concerns about space overhead and correctness.
</p>
<ul>
<li>Exceptions either require external jump tables or extra bookkeeping instructions.</li>
<li>RTTI requires extra data in vtables and extra classes that are difficult to optimize away.</li>
<li>The heap is a big set of global state.  In addition, heap exhaustion is typically expressed via exception.  Some embedded systems don't even have a heap.</li>
<li>Thread-local storage requires extra code in the operating system for support.  In addition, if one thread uses thread local storage, that cost is imposed on other threads.</li>
<li>Many embedded systems don't have floating point hardware, and software emulated floating point can drag in large runtimes that are difficult to optimize away.  Also, most operating systems speed up system calls by not saving and restoring floating point state.  That means that kernel uses of floating point operations require extra care to avoid corrupting user state.</li>
<li>Some functions require global or thread-local storage.  These functions have been omitted or removed from the freestanding library.  Examples are the locale aware functions and the C random number functions.</li>
</ul>
<p>
For the <code>&lt;algorithms&gt;</code> header, we would only be able to support sequential execution of parallel algorithms.  Since this adds little value, the execution policy overloads will be omitted.
</p><p>
This proposal doesn't remove problematic features from the language, but it does make it so that the bulk of the freestanding standard library doesn't require those features.  Users that disable the problematic features (as is existing practice) will still have portable portions of the standard library at their disposal.
</p>
<h1>VIII. Technical Specifications</h1>
<h2>Facilities no longer required for freestanding implementations</h2>
Usages of the operating system
<ul>
<li><code>&lt;new&gt; hardware_destructive_interference_size</code></li>
<li><code>&lt;new&gt; hardware_constructive_interference_size</code></li>
</ul>

<h2>Facilities newly required for freestanding implementations</h2>
Portions of <code>&lt;cstdlib&gt;</code>
<ul>
<code><li>div_t</li>
<li>ldiv_t</li>
<li>lldiv_t</li>
<li>EXIT_FAILURE</li>
<li>EXIT_SUCCESS</li>
<li>_Exit</li>
<li>atoi</li>
<li>atol</li>
<li>atoll</li>
<li>bsearch</li>
<li>qsort</li>
<li>abs(int)</li>
<li>abs(long int)</li>
<li>abs(long long int)</li>
<li>labs</li>
<li>div</li>
<li>ldiv</li>
<li>lldiv</li></code>
</ul>
<p>
All the error <code>#defines</code> in <code>&lt;cerrno&gt;</code>, but not <code>errno</code>.
</p><p>
The <code>errc</code> enum from <code>&lt;system_error&gt;</code>.
</p><p>
All of <code>&lt;utility&gt;</code> and <code>&lt;tuple&gt;</code>.
</p><p>
Portions of <code>&lt;memory&gt;</code>.
</p>
<ul>
<li><b>TODO: put std::allocator here in constexpr contexts only?</b></li>
<li><code>pointer_traits</code></li>
<li><code>align</code></li>
<li>23.10.10, specialized algorithms</li>
</ul>
<p>
Most of <code>&lt;functional&gt;</code>.  <b>Omit</b> the following.
<ul>
<li>23.14.13, polymorphic function wrappers (i.e. <code>std::function</code> and friends).</li>
<li>23.14.14.2, <code>boyer_moore_searcher</code></li>
<li>23.14.14.3, <code>boyer_moore_horspool_searcher</code></li>
</ul>
</p><p>
All of <code>&lt;ratio&gt;</code>.
</p><p>
Most of <code>&lt;chrono&gt;</code>.  <b>Omit</b> 23.17.7, Clocks.
</p><p>
Portions of <code>&lt;charconv&gt;</code>.
</p>
<ul>
<li><code>to_chars_result</code></li>
<li><code>from_chars_result</code></li>
<li><code>to_chars</code>(integral)</li>
<li><code>from_chars</code>(integral)</li>
</ul>
<p>
The <code>char_traits</code> class from <code>&lt;string&gt;</code>.
</p><p>
Portions of <code>&lt;cstring&gt;</code>.
<ul>
<code><li>memcpy</li>
<li>memmove</li>
<li>strcpy</li>
<li>strncpy</li>
<li>strcat</li>
<li>strncat</li>
<li>memcmp</li>
<li>strcmp</li>
<li>strncmp</li>
<li>memchr</li>
<li>strchr</li>
<li>strcspn</li>
<li>strpbrk</li>
<li>strrchr</li>
<li>strspn</li>
<li>strstr</li>
<li>memset</li>
<li>strlen</li>
</code></ul>
Portions of <code>&lt;cwchar&gt;</code>.
<ul>
<code><li>wcscpy</li>
<li>wcsncpy</li>
<li>wmemcpy</li>
<li>wmemmove</li>
<li>wcscat</li>
<li>wcsncat</li>
<li>wcscmp</li>
<li>wcsncmp</li>
<li>wmemcmp</li>
<li>wcschr</li>
<li>wcscspn</li>
<li>wcxpbrk</li>
<li>wcsrchr</li>
<li>wcsspn</li>
<li>wcsstr</li>
<li>wcstok</li>
<li>wmemchr</li>
<li>wcslen</li>
<li>wmemset</li>
</code></ul>
<p>
All of <code>&lt;iterator&gt;</code> except for the stream iterators and the insert iterators.
</p><p>
Most of <code>&lt;algorithm&gt;</code> and <code>&lt;numeric&gt;</code>.  The ExecutionPolicy overloads will not be included.  The following functions will be <b>omitted</b> due to the usage of temporary buffers:
</p>
<ul>
<code><li>stable_sort</li>
<li>stable_partition</li>
<li>inplace_merge</li>
</code></ul>
<p>
Portions of <code>&lt;random&gt;</code>.  The following portions will be <b>omitted</b>:
</p>
<ul>
<code><li>random_device</li>
<li>uniform_real_distribution</li>
<li>exponential_distribution</li>
<li>gamma_distribution</li>
<li>weibull_distribution</li>
<li>extreme_value_distribution</li>
<li>normal_distribution</li>
<li>lognormal_distribution</li>
<li>chi_squared_distribution</li>
<li>cauchy_distribution</li>
<li>fisher_f_distribution</li>
<li>student_t_distribution</li>
<li>piecewise_constant_distribution</li>
<li>piecewise_linear_distribution</li>
</code></ul>
A small portion of <code>&lt;cmath&gt;</code> will be present.
<ul>
<code><li>abs(int)</li>
<li>abs(long int)</li>
<li>abs(long long int)</li>
</code></ul>
A portion of <code>&lt;cinttypes&gt;</code> will be present.
<ul>
<code><li>imaxabs</li>
<li>imaxdiv</li>
<li>abs(intmax_t)</li>
<li>div(intmax_t, intmax_t)</li>
</code></ul>
<h2>Notable omissions</h2>
<p>
<code>bitset</code> is not included because many of its functions throw as part of a range check.
</p><p>
<code>errno</code> is not included as it is global state.  In addition, errno is best implemented as a thread_local variable.
</p><p>
<code>error_code</code>, <code>error_condition</code>, and <code>error_condition</code> all have <code>string</code> in the interface.
</p><p>
Many string functions (<code>strtol</code> and family) rely on <code>errno</code>.
</p><p>
<code>string_view</code> and <code>array</code> have methods that can throw exceptions.
</p><p>
<code>assert</code> is not included as it requires a stderror stream.
</p><p>
<code>&lt;variant&gt;</code> and <code>&lt;optional&gt;</code> could work in a freestanding environment if their interfaces didn't rely on exceptions.
</p><p>
<code>&lt;cctype&gt;</code> and <code>&lt;cwctype&gt;</code> rely heavily on global locale data.
</p><p>
<code>unique_ptr</code> is generally used for heap management, but is occasionally used as a makeshift RAII object for other resources.  The use of the <code>default_delete</code> class in the template parameters is what dooms this class.  In the future, <a href="http://wg21.link/p0052"><code>unique_resource</code> and <code>scope_exit</code></a> may satisfy the non-deleting use cases that <code>unique_ptr</code> currently fills.
</p>
<h1>IX. Acknowledgements</h1>
<p>
Thanks to Brandon Streiff, Joshua Cannon, Phil Hindman, and Irwan Djajadi for reviewing this proposal.
</p><p>
Similar work was done in the C++11 timeframe by Lawrence Crowl and Alberto Ganesh Barbati in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3256.html">N3256</a>.
</p><p>
CppCon talks on getting C++ support in various unusual environments:
</p><p>
[Baker2017] CppCon 2017: Billy Baker "Almost Unlimited Modern C++ in Kernel-Mode Applications"
</p><p>
[Quinn2016] CppCon 2016: Rian Quinn "Making C++ and the STL Work in the Linux / Windows Kernels"
</p><p>
[Bratterud2017] CppCon 2017: Alfred Bratterud "Deconstructing the OS: The devil's In the side effects"
</p>
</body>
</html>
