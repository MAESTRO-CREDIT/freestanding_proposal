<!DOCTYPE html>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<html>
<style type="text/css">
  ins, ins * { text-decoration:none; font-weight:bold; background-color:#A0FFA0 }
  del, del * { text-decoration:line-through; background-color:#FFA0A0 }
  #hidedel:checked ~ * del, #hidedel:checked ~ * del * { display:none; visibility:hidden }

blockquote {
  padding: .5em;
  border: .5em;
  border-color: silver;
  border-left-style: solid;
}

blockquote.std { color: #000000; background-color: #F1F1F1;
  border: 1px solid #D1D1D1;
  padding-left: 0.5em; padding-right: 0.5em; }
blockquote.stdins { text-decoration: underline;
  color: #000000; background-color: #C8FFC8;
  border: 1px solid #B3EBB3; padding: 0.5em; }
blockquote.stddel { text-decoration: line-through;
  color: #000000; background-color: #FFEBFF;
  border: 1px solid #ECD7EC;
  padding-left: 0.5em; padding-right: 0.5em; }

p.grammarlhs { margin-bottom: 0 }
p.grammarrhs { margin-left:8em; margin-top:0; margin-bottom:0; text-indent:-4em }

div.wrapper {
    max-width: 60em;
    margin: auto;
}

a { text-decoration: none; }

a.hidden_link {
    text-decoration: none;
    color: inherit;
}

li {
    margin-top: 0.0em;
    margin-bottom: 0.0em;
}

h1 { line-height: 1; }
h2 { line-height: 1; }
h3 { line-height: 1; }
h4 { line-height: 1; }

:target { background-color: #C9FBC9; }
:target .codeblock { background-color: #C9FBC9; }
:target ul { background-color: #C9FBC9; }

.abbr_ref { float: right; }

.folded_abbr_ref { float: right; }
:target .folded_abbr_ref { display: none; }

:target .unfolded_abbr_ref { float: right; display: inherit; }
.unfolded_abbr_ref { display: none; }

.secnum { display: inline-block; min-width: 35pt; }
.annexnum { display: block; }

div.sourceLinkParent {
    float: right;
}

a.sourceLink {
    position: absolute;
    opacity: 0;
    margin-left: 10pt;
}

a.sourceLink:hover {
    opacity: 1;
}

div.marginalizedparent {
    position: relative;
    left: -5em;
}

div.footnoteNumberParent {
    position: relative;
    left: -4.7em;
}

a.marginalized {
    position: absolute;
    font-size: 75%;
    text-align: right;
    width: 5em;
}

a.enumerated_item_num {
    position: relative;
    left: -3.5em;
    display: inline-block;
    margin-right: -3em;
    text-align: right;
    width: 3em;
}

div.para { margin-bottom: 0.6em; margin-top: 0.6em; text-align: justify; }
div.section { text-align: justify; }
div.sentence { display: inline; }

span.indexparent {
    display: inline;
    position: relative;
    float: right;
    right: -1em;
}

a.index {
    position: absolute;
    display: none;
}

a.index:before { content: "Ã¢Å¸Âµ"; }
    /* this way the content is not selectable */

a.index:target {
    display: inline;
}

.indexitems {
    margin-left: 2em;
    text-indent: -2em;
}

div.itemdescr {
    margin-left: 3em;
}

.bnf {
    font-family: serif;
    margin-left: 40pt;
    margin-top: 0.5em;
    margin-bottom: 0.5em;
}

.ncbnf {
    font-family: serif;
    margin-top: 0.5em;
    margin-bottom: 0.5em;
    margin-left: 40pt;
}

.bnftab {
    font-family: serif;
    font-style: italic;
    margin-left: 40pt;
    margin-top: 0.5em;
    margin-bottom: 0.5em;
}

.ncsimplebnf {
    font-family: serif;
    font-style: italic;
    margin-top: 0.5em;
    margin-bottom: 0.5em;
    margin-left: 40pt;
}

.ncbnftab {
    font-family: serif;
    font-style: italic;
    margin-top: 0.5em;
    margin-bottom: 0.5em;
    margin-left: 40pt;
}

.bnfkeywordtab {
    margin-top: 0.5em;
    margin-bottom: 0.5em;
    margin-left: 40pt;
}

span.textnormal {
    font-style: normal;
    font-family: serif;
    white-space: normal;
    display: inline-block;
}

span.descr { font-style: normal; font-family: serif; }
span.grammarterm { font-style: italic; }
span.term { font-style: italic; }
span.terminal { font-family: monospace; font-style: normal; }
span.nonterminal { font-style: italic; }
span.tcode { font-family: monospace; font-style: normal; }
span.textbf { font-weight: bold; }
span.textsc { font-variant: small-caps; }
a.nontermdef { font-style: italic; font-family: serif; }
span.emph { font-style: italic; }
span.techterm { font-style: italic; }
span.mathit { font-style: italic; }
span.mathsf { font-family: sans-serif; }
span.mathrm { font-family: serif; font-style: normal; }
span.textrm { font-family: serif; }
span.textsl { font-style: italic; }
span.mathtt { font-family: monospace; font-style: normal; }
span.mbox { font-family: serif; font-style: normal; }
span.ungap { display: inline-block; width: 2pt; }
span.textit { font-style: italic; }
span.texttt { font-family: monospace; }
span.tcode_in_codeblock { font-family: monospace; font-style: normal; }

span.phantom { color: white; }
span.math { }

span.mathblock {
    display: block;
    margin-left: auto;
    margin-right: auto;
    margin-top: 1.2em;
    margin-bottom: 1.2em;
    text-align: center;
}

span.mathalpha {
    font-style: italic;
}

span.synopsis {
    font-weight: bold;
    margin-top: 0.5em;
    display: block;
}

span.definition {
    font-weight: bold;
    display: block;
}

.codeblock {
    margin-left: 1.2em;
    line-height: 127%;
}

code {
    font-family: monospace;
    font-style: normal;
}

code.itemdecl {
    margin-top: 2ex;
    white-space: pre;
    display: block;
}

.comment {
    font-style: italic;
    font-family: serif;
}

span.textsuperscript {
    vertical-align: super;
    font-size: smaller;
    line-height: 0;
}

.footnotenum { vertical-align: super; font-size: smaller; line-height: 0; }

.footnote {
    font-size: small;
    margin-left: 2em;
    margin-right: 2em;
    margin-top: 0.6em;
    margin-bottom: 0.6em;
}

div.minipage {
    display: inline-block;
    margin-right: 3em;
}

div.numberedTable {
    text-align: center;
    margin: 2em;
}

div.figure {
    text-align: center;
    margin: 2em;
}

table {
    border: 1px solid black;
    border-collapse: collapse;
    margin-left: auto;
    margin-right: auto;
    margin-top: 0.8em;
    text-align: left;
    hyphens: none; /* otherwise some columns get very narrow, e.g. [tab:hash] */
}

td, th {
    padding-left: 1em;
    padding-right: 1em;
    vertical-align: top;
}

td.left {
    text-align: left;
}

td.right {
    text-align: right;
}

td.center {
    text-align: center;
}

td.justify {
    text-align: justify;
}

td.border {
    border-left: 1px solid black;
}

tr.rowsep, td.cline {
    border-top: 1px solid black;
}

tr.capsep {
    border-top: 3px solid black;
    border-top-style: double;
}

th {
    border-bottom: 1px solid black;
}

span.centry {
    font-weight: bold;
}

div.table {
    display: block;
    margin-left: auto;
    margin-right: auto;
    text-align: center;
    width: 90%;
}

span.indented {
    display: block;
    margin-left: 2em;
    margin-bottom: 1em;
    margin-top: 1em;
}
</style>

<title>noexcept policy for SD-9 (throws nothing)</title>
<body>
<h1>noexcept policy for SD-9 (throws nothing)</h1>
Document number: D0000R0 TODO<br/>
Date: 2023-09-23 TODO<br/>
Reply-to: Ben Craig &lt;ben dot craig at gmail dot com&gt;<br/>
Audience: Library Evolution Working Group

<h1>Changes from previous revisions</h1>
First revision!

<h1>Introduction</h1>
<p>
The first priority of this paper is to establish a lasting policy on the usage of <code>noexcept </code> in the standard library that avoids re-litigation for a few years.
</p><p>
The second priority is to establish the author's preferred policy.
</p><p>
This paper currently recommends the policy that functions that LEWG and LWG agree cannot throw should be marked unconditionally <code>noexcept</code>.
</p><p>
This paper discusses an alternative policy that library functions that could exhibit undefined behavior due to precondition violations should not be marked <code>noexcept</code> (AKA the "Lakos rule", AKA the narrow noexcept policy).
</p><p>
With luck, one of these two policies can gain consensus.
</p>

<h1>Prior <code>noexcept</code> Discussions</h1>

<h2>History papers</h2>
<a href="https://www.open-std.org/JTC1/SC22/WG21/docs/papers/2009/n2855.html">N2855, Rvalue References and Exception Safety</a><br/>
<a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2983.html">N2983, Allowing Move Constructors to Throw</a><br/>
<a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3248.pdf">N3248, noexcept Prevents Library Validation.</a><br/>
<a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3279.pdf">N3279, Conservative use of noexcept in the Library</a><br/>
<a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0884r0.pdf">P0884R0, Extending the noexcept Policy, Rev0</a><br/>
<a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2920r0.pdf">P2920R0, Library Evolution Leadership's Understanding of the Noexcept Policy History </a><br/>

<h2>Throws Nothing Rule</h2>
<a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1656r2.html">P1656R2, "Throws: Nothing" should be noexcept</a><br/>
<a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2148r0.pdf">P2148R0, Library Evolution Design Guidelines</a><br/>
<a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p0000r0.html">TODO: This paper</a><br/>

<h2>Narrow <code>noexcept</code> / Lakos Rule</h2>
<a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2831r0.pdf">P2831R0, Functions having a narrow contract should not be noexcept</a><br/>
<a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2837r0.pdf">P2837R0 Planning to Revisit the Lakos Rule </a><br/>
<a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2858r0.html">TODO(is this pro lakos?) P2858R0, Noexcept vs contract violations </a><br/>
<a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2861r0.pdf">P2861R0, The Lakos Rule: Narrow Contracts And `noexcept` Are Inherently Incompatible </a><br/>
<a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2949r0.pdf">P2949R0, Slides for P2861R0: Narrow Contracts and `noexcept` are Inherently Incompatable </a><br/>
<a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2946r0.pdf">P2946R0, A flexible solution to the problems of `noexcept` </a><br/>

<h1>Policies in question</h1>
These two policies only differ on point b.

<h2>Common parts (proposed)</h2>
This wording matches the shared wording from P1656R2 and P0884R0.
<ol type="a">
    <li><p>No library destructor should throw. They shall use the implicitly supplied (non-throwing) exception specification.</p></li>
    <li><p><i>See below</i></p></li>
    <li><p>If a library swap function, move-constructor, or move-assignment operator is conditionally-wide (i.e.&nbsp;can be proven to not throw by applying the <code>noexcept</code> operator) then it should be marked as conditionally <code>noexcept</code>.</p></li>
    <li><p>If a library type has wrapping semantics to transparently provide the same behavior as the underlying type, then default constructor, copy constructor, and copy-assignment operator should be marked as conditionally <code>noexcept</code> the underlying exception specification still holds.</p></li>
    <li><p>No other function should use a conditional <code>noexcept</code> specification.</p></li>
    <li><p>Library functions designed for compatibility with “C” code (such as the atomics facility), may be marked as unconditionally <code>noexcept</code>.</p></li>
</ol>

<h2>Throws Nothing Rule (proposed)</h2>
This wording matches the wording in P1656R2 "Throws: Nothing" should be noexcept.

<p>b. Each library function that LEWG and LWG agree cannot throw, should be marked as unconditionally <code>noexcept</code>.</p>

<h2>Narrow <code>noexcept</code> / Lakos Rule (not proposed in this revision></h2>
This wording matches the wording in P0884R0 Extending the noexcept Policy, Rev0.

<p>b. Each library function having a <em>wide</em> contract (i.e., does not specify undefined behavior due to a precondition) that the LWG agree cannot throw, should be marked as unconditionally <code>noexcept</code>.</p>

<h1>Why should we establish any <code>noexcept</code> policy?</h1>
<h2>Contracts</h2>
<h2>Consistency over preference</h2>
<p>
There are some design areas where the difference in two choices is of little consequence.
LEWG will often spend some time rediscovering the trade-offs and existing practice around the differences, and then make a somewhat arbitrary decision.
In these cases, LEWG tends to bias towards "whatever the bulk of the standard is currently doing".
</p><p>
LEWG could become more self consistent by documenting one way, and then requiring authors to either follow the policy, or provide rationale for why the policy should not be applied in this case.
</p><p>
The explicit-ness of multi-argument constructors is one such area. <a href="https://wg21.link/P2711R1">[P2711R1] Making multi-param constructors of views explicit </a>.
</p>
<h2>Changes in direction</h2>
<p>
Sometimes, LEWG follows one design pattern in the standard, then discovers or invents a new pattern.
The new pattern is inconsistent with the old pattern.
Authors then wonder whether to follow the new pattern or old pattern.
</p><p>
This is a reasonable place for LEWG to document a policy.
</p><p>
Using hidden <code>friend</code>s for non-member operators is one example of a change in direction.
Whether to make all new "free functions" in the standard library customization point objects (like <code>std::ranges</code>) is another.
</p>

<h2>Cross group trust</h2>
<p>
There are a lot of discussions happening concurrently within WG21.
Sometimes, one group wants to rely on conventions from another group.
These policies help people focus on the groups they are needed, rather than spend a large portion of their time ensuring their policy is followed (or not) in LEWG.
</p><p>
An example policy here would be ensuring that <code>const</code> means either shallow bitwise const or internally synchronized.
The concurrency study group is likely relying on that convention to be followed, so changing <code>const</code> directions would cause surprise.
</p>

<h1>Why the LEWG noexcept policy isn't actually that important</h1>

<h1>Arguments</h1>
<h2>Standard library policies need not be C++ library policies</h2>

<h2>Library Testing</h2>
n3248
<h3>Precondition checks / contracts need testing</h3>
n3248
P2831R0
<h3>Potential contracts features</h3>
<h3>Contracts workarounds</h3>
<h3>noexcept macro</h3>
n3248
P2831R0
<h3>setjmp/longjmp</h3>
n3248
P2831R0
<h3>child threads, fibers, and signals</h3>
P2831R0
<h3>magic compiler exception exploiting precondition UB</h3>
<h3>Death tests</h3>
p1656r2
* Quantity of information
P2831R0
* Speed
P2831R0
* Only GoogleTest
P2831R0
* Limited platforms(browsers, embedded)
P2831R0
* Spawn vs clone vs fork

<h2>Termination risk</h2>
P2831R0
<h2>Algorithmic optimizations and exception safety</h2>
N2855, N2983, N3248

<h2>Codegen changes</h2>
<h3>Destructors</h3>
<h3>Optimization<h3>
N2983
N3248
p1656r2
P2831R0
<h3>Bloat</h3>
p1656r2
P2831R0

<h2>Implementations don't diagnose contract violations with exceptions</h2>
p1656r2
P2831R0

<h2>Other implementations</h2>
P2831R0

<h2>Diagnosing UB</h2>
p1656r2

<h2><code>noexcept</code>-accuracy</h2>
p1656r2
P2831R0 (purity not worth it)

<h2>Doesn't matter since implementations can already add noexcept</h2>
P2831R0

<h2>Precondition UB and noexcept contradict</h2>
P2831R0

<h2>Narrow to wide backwards compatibility</h2>
P2831R0

<h2>Standard library should provide an example of good user library design</h2>
P2831R0

<h2>Exceptions disabled</h2>
P2831R0
<h3>noexcept operator doesn't change</h3>


<h1>Suggested polls</h1>

<h2>Any policy is better than no policy</h2>
<b>Poll:</b> Having a noexcept policy in place is more important than having my preferred policy, so a head-to-head poll is an acceptable way to select the policy.<br/>
5-way poll (SF/WF/N/WA/SA)<br/>

<p>
If the "any policy" poll gains consensus, then we do a head-to-head poll on the policies.
</p><p>
If the "any policy" poll does not gain consensus, then we do two 5 way polls.
Whichever poll has consensus in general, and has more consensus than the other, wins.
It is possible that neither has consensus.
If LEWG is a little crazy, then both may have consensus.
</p><p>
If we do these as electronic polls (and we should), then all four polls should run.
</p>

<h2>Head-to-head policy poll</h2>
<b>Poll:</b> Which policy do we adopt?<br/>
3-way poll "Lakos rule"/Neutral/"Throws nothing rule"<br/>

<h2>Adopt the "Lakos rule" noexcept policy</h2>
<b>Poll:</b> Adopt the "Lakos rule" noexcept policy and create SD-9 with the proposed "Lakos rule" text.<br/>
5-way poll (SF/WF/N/WA/SA)<br/>

<h2>Adopt the "Throws nothing rule" noexcept policy</h2>
<b>Poll:</b> Adopt the "Throws nothing rule" noexcept policy and create SD-9 with the proposed "Throws nothing rule" text.<br/>
5-way poll (SF/WF/N/WA/SA)<br/>


<h1>Proposed SD-9 text</h1>

<h1>References</h1>
</body>
</html>
