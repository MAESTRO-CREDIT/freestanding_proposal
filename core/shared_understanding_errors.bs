<pre class='metadata'>
Title: Shared understanding of errors and exceptions
Shortname: D2018
Revision: 0.3
Audience: SG14, EWG
Status: D
Group: WG21
URL: TODO
!Source: <a href="https://github.com/ben-craig/freestanding_proposal/blob/master/core/shared_understanding_errors.bs">github.com/ben-craig/freestanding_proposal/blob/master/core/shared_understanding_errors.bs</a>
Editor: Ben Craig, NI, ben.craig@gmail.com
Editor: Niall Douglas, s_sourceforge@nedprod.com
Abstract:
Markup Shorthands: markdown yes
</pre>

Introduction {#intro}
=====================
This paper aims to reflect the shared understanding of the authors regarding error handling and exceptions.  The goal is to avoid talking past each other, and productively help us gain consensus.  This paper does not recommend any specific actions or changes.

Error handling is a topic with abundant technical and usability trade-offs.  This paper will attempt to highlight many of these trade-offs, both positive and negative.

Areas of agreement {#agree}
===========
Big picture {#big_picture}
--------------------------
1. We should continue to discuss error handling and exceptions in order to drive improvements. [[#discuss]]
1. Large portions of the C++ community build their code with exceptions turned off. [[#eh_off]]

Exception and error code performance comparisons {#perf_cmp}
--------------------------
1. [=Table-based exceptions=] have the fastest known [=happy path=] performance among [=program-recoverable=] error handling strategies. [[P1886R0]]
1. [=Sad path=] performance of exceptions is more than 100x worse than happy path performance on table-based exception implementations. [[P1886R0]]
1. Error codes perform the same or worse than table-based exceptions on the happy path. [[P1886R0]]
1. Error codes perform better than table-based exceptions on the sad path. [[P1886R0]]
1. When available, branch prediction and speculative execution can mitigate the happy path performance impact of error codes in many use cases.
1. The standard deviation of sad path execution time of table-based exceptions is more than 50x that of error codes. [[P1886R0]]
1. Table-based exceptions have higher space overhead than error codes. [[P1640R1]]
1. [[P0709]] exceptions, [[P1095]] failures, and `expected` are likely to have performance characteristics similar to error codes.
1. Mainstream implementations of table-based exceptions have room for optimization. [[#room_for_optimizations]]
1. There are other exception implementation approaches that may address the challenges with table-based exceptions, or at least provide a different set of trade offs.  [[#other_approaches]]
1. Platform ABIs place substantial constraints on how much exceptions can change. [[ItaniumEHABI]]
1. The performance gap between happy and sad path exception performance has widened over time because of lack of development on the sad path. [[P1947R0]]
1. The performance characteristics of exceptions are a program-global decision made by the toolchain implementer. [[#global_decision]]
1. Developers may want different performance characteristics for error handling in different parts of the program. [[#global_decision]]

Avoiding overhead {#avoiding_overhead}
--------------------
1. You shouldn't pay for what you don't use. [[DE1994]]
1. Callers of `expected<void, std::errc> f1() noexcept;` are using `expected`, and pay the associated costs of `expected`.
1. Callers of `std::errc f2() noexcept;` are using error codes, and pay the associated costs of error codes.
1. Callers of `void f3();` are using exceptions, and pay the associated costs of exceptions. [[#using_is_easy]]
1. A program can use exceptions (and therefore pay for them) even when it doesn't have `try`, `catch`, or `throw` in the program. [[#using_is_easy]]

Error terminates {#terminates}
--------------------------
1. Error terminates are not suitable for program-recoverable error handling.
1. Error terminates are useful as the primary error handling mechanism in many applications.
1. Error terminates are as fast or faster than table-based exceptions. [[P1886R0]]
1. Error terminates are smaller than table-based exceptions. [[P1640R1]]
1. In general, exception support adds non-zero overhead to programs that only need error terminates. [[P1640R1]]

Error propagation usability {#error_prop_usability}
--------------------------
1. Exception syntax allows constructors and operators to propagate errors.
1. Error code syntax does not allow constructors or operators to propagate errors.
1. Manual error propagation requires a lot of mistake-prone boilerplate. [[#error_prop]]
1. Forgetting to test for an error code is a common source of bugs. [[#error_prop]]
1. Automatic error propagation adds invisible control flow that can be easy to overlook. [[#error_prop]]
1. Forgetting to account for a propagating exception is a common source of bugs. [[#error_prop]]
1. #SUBJECTIVE# Automatic error propagation is preferable. [[#error_prop]]
1. RAII is an enormous boon to error handling in general. [[#error_prop]]
1. Code that does not use RAII is exceedingly difficult to port to exceptions.
1. The degree to which error categorization should be reflected in function signatures is a polarizing topic in the C++ community.
1. The visibility of error handling is a polarizing topic in the C++ community.
1. Opinions of error handling visibility can vary wildly based on the code under discussion.
1. Dual error interface libraries are not ideal (e.g. `std::filesystem`).
1. Authors of an API do not always know whether a failure is expected, common, or program-recoverable.

Real-time cases {#real_time_summary}
--------------------------
1. Table-based exceptions are challenging to use during operations with hard deadlines (i.e. real-time operations). [[#real_time]]
1. Table-based exceptions are well suited to the no-deadline portions of real-time applications. [[#real_time]]
1. In some code paths, a 20% reduction in happy path performance is acceptable if it results in a 100x improvement in sad path performance.  [[#real_time]]

Application domains {#application_domains}
--------------------------
1. `try`, `catch` and `throw` are not supported in the context of a signal. [support.signal](http://eel.is/c++draft/support.signal)
1. Table-based exceptions are challenging on microcontrollers due to tight space constraints. [[#microcontrollers]]
1. Implementing full C++ exception support in mainstream operating system kernel environments is either challenging, or impossible, without modifying the operating system kernel itself. [[#kernel]]
1. Partial C++ exception support is possible in mainstream operating system kernels without modifying the operating system kernel itself. [[#kernel]]
1. Table-based exceptions are challenging on bare-metal, in part because of the high implementation cost and dependency on operating system facilities. [[#baremetal]]
1. Table-based exceptions are challenging on FPGAs because of space constraints, and because of indirect calls. [[#fpgas]]
1. Table-based exceptions are well suited to applications where extra milliseconds of latency on the failure path will go unnoticed. [[#unnoticed_fail]]
1. #DUP?# Table-based exceptions are well suited to interactive and low-latency applications where extra milliseconds of latency on the failure path will go unnoticed. [[#unnoticed_fail]]
1. Table-based exceptions are well suited to throughput-oriented applications where failure is rare and can be modeled with a random (i.e. non-correlated) process. [[#throughput_apps]]
1. Table-based exceptions are well suited to applications where all speed improvements on the happy path provide value. [[#cant_go_fast_enough]]
1. Flow-control based error handling is challenging on GPUs because it causes divergent code flow, and can inhibit the most valuable optimization in that domain. [[#gpus]]

Exception allocations {#eh_alloc_summary}
--------------------------
1. Throwing an exception requires a dynamic allocation. [[#eh_alloc]]
1. It is challenging to support heap allocations for exception objects in kernel, microcontroller, bare-metal, and FPGA environments. [[#eh_alloc]]
1. It is challenging to support stack allocations for exception objects in kernel, microcontroller, bare-metal, and FPGA environments, due to limited stack space. [[#eh_alloc]]
1. Exceptions require out-of-band mutable storage that is local to a thread (though not necessarily <i>thread-local-storage</i>). [[#tls]]

Switching error mechanisms {#error_mechanisms}
--------------------------
1. Migrating a large code base from one error handling strategy to another is a significant undertaking.
1. Many users do not use exceptions because of exception unsafe code. [[#dubious_business_value]]
1. The business value for implementers to improve the sad path exception performance is dubious. [[#dubious_business_value]]

N+1 summary {#n_plus_one_summary}
--------------------------
1. [[P0709]] exceptions and [[P1095]] failures are an additional form of error handling. [[#n_plus_one]]
1. [[P0323]] `expected` is an additional form of error handling. [[#n_plus_one]]
1. If [[P0709]] exceptions, [[P1095]] failures, and / or `expected` are standardized, all prior error handling mechanisms will still be seen in the wild for decades to come. [[#n_plus_one]]
1. Users routinely write code that translates between different error handling schemes. [[#n_plus_one]]
1. Translating between different error handling schemes usually requires error prone boilerplate. [[#n_plus_one]]
1. A new error mechanism may replace one or more old mechanisms in teaching materials.  [[#n_plus_one]]
1. A new error mechanism may replace one or more old mechanisms in new code bases.  [[#n_plus_one]]

Error propagation and carrying arbitrary information {#arb_info}
--------------------------
1. Error handling can be coarsely decomposed into a [=failure flag=], a [=failure classification=], and a [=failure payload=].
1. Failure flags and failure payloads can be transported via different mechanisms. [[LEAF]]
1. Calling code is coupled to the failure flag mechanism of callees, as calling code needs to be able to [=unwind=] correctly.
1. In the general case, unwinding cannot be done correctly with error codes across functions and languages that are unaware of error codes.
1. In the general case, unwinding (particularly cleanup) cannot be done correctly with C++ exceptions across functions and languages that are unaware of C++ exceptions.
1. Exceptions allow the transportation of an arbitrary failure payload from a callback, through the invoker.
1. Error codes can be constructed that allow the transportation of an arbitrary failure payload from a callback, through the invoker (e.g. a std::pair<int, std::any>).
1. Error codes, in the general case, cannot be used to propagate failure payloads across code that is unaware of error codes.
1. In most cases, thread local storage can be used to propagate error information across code that is unaware of thread local storage.

Tooling {#tooling}
------------------
1. The sad path of integer error code based programs is roughly as analyzable as the happy path. [[#sad_path_analysis]]
1. The sad path of dynamically-typed exception based programs is much harder to analyze than the happy path. [[#sad_path_analysis]]


Rationale {#rationale}
==========

Discussion provides value {#discuss}
-------------------------------
The continuing error handling discussions serve to remind the committee and the community of forgotten rationale, uncommon use cases, and unfamiliar domains.

These discussions could result in new facilities in C++, improved quality of toolchain implementations, or even changes to hardware and software outside the purview of WG21 (e.g. operating systems, GPU silicon, C error handling).

Exceptions turned off {#eh_off}
-------------------------------
The [[SC++F_2018]], [[SC++F_2019]], and [[SC++F_2020]] results indicate that around half of all developers are not allowed to use exceptions in all projects, and more than 15% aren't allowed to use exceptions at all.

The Standard C++ Foundation surveys are more likely to be answered by enfranchised C++ developers, and as a result have a bias.  Unfortunately, we don't have data to know how it is biased, as it is exceedingly difficult to get data about the "dark matter" programmers.

Regardless, the survey data indicates that a significant portion of the C++ community does not use exceptions, even if we don't know the exact size of that portion.

Room for optimizations {#room_for_optimizations}
------------------------------------------------
There are cases where the compiler could detect certain C++ exception patterns and avoid many of the costs of exception handling.  [[P1676R0]] and [[Glisse2013]] discuss many of these patterns.  It should be possible to optimize cases where all code between a `throw` and a matching `catch` is visible.

[[MoFH4]] discusses optimizations made to the Microsoft Visual Studio 2019 x86_64 compiler that substantially reduced size overhead, without breaking ABI.

Error propagation {#error_prop}
-------------------------------
Programs based on error codes are usually littered with statements of the form `if(FAILED(err)) {return err;}`.  Programs based on error codes where the error code is the return value also have boilerplate where they need to declare out-parameters in advance of a function call, and even more boilerplate when results of functions need to be composed.

Error codes can be accidentally ignored.  Doing "the right thing" requires the programmer to write additional code in order to avoid "the wrong thing".  `[[nodiscard]]` substantially improves this situation.

[[Cargill1994]] covers many pitfalls of forgotten exceptions, especially those involved when calling functions associated with template argument types (e.g. potentially throwing copy constructors).  The techniques and idioms available in 2020 are significantly more advanced than those that were well known in 1994, but the problems mentioned in the article still exist today.

Whether using error codes or exceptions, RAII makes code substantially more mistake-resistant.  Success paths, error paths, early returns, and exceptions can all be handled through the same mechanism.

Real-time environments {#real_time}
----------------------------------
In real-time environments, the worst case execution time (WCET) in certain code paths must be below a certain threshold for a system to be correct.  The thresholds are often on the order of hundreds of microseconds.  Modern table-based exception implementations take multiple microseconds to throw an exception on the sad path in the best of cases, while taking nanoseconds to run in the happy path [[P1886R0]].  This wide disparity in execution times makes WCET budgeting difficult.  For WCET purposes, developers need to minimize the maximum runtime, and that usually means choosing something besides table-based exceptions.  Modern table-based exception implementations will often allocate memory, and this can reduce the level of determinism in the timings.

Not every code path in a real-time environment needs to track WCET.  In many environments, there will be low priority tasks that do not have hard deadlines.  In these code paths, table-based exceptions are fine.

Microcontroller environments {#microcontrollers}
-----------------------------------
Microcontrollers are notoriously space constrained.  These systems can range from having megabytes of RAM and ROM to having bytes of ROM and only registers for mutable state.  Increasing the amount of storage available on microcontrollers is often a complicated affair.  The next larger offering will often take more physical space, consume more power, and have a different pin-out.  A larger part almost certainly costs more, cutting into profit margins.

Table-based exceptions have a large one-time cost for the exception handling machinery [[P1640R1]].  In some systems, this one-time cost exceeds the entire space budget of the program.  The incremental cost for table-based exceptions is larger than that of integer error codes, so at no point do you "break even".  Even if the incremental costs were smaller, it is unlikely that a microcontroller based program would be capable of growing large enough to gain the benefit, without going over the size budget.

Kernel environments {#kernel}
-----------------------------
Some aspects of exception handling require storage that is local to a thread ([[#tls]]).  Microsoft Windows, Linux, Apple OSX, and the various BSDs do not implement arbitrary TLS that is exposed to driver developers.  This means that implementing these aspects of exception handling require one of the following tactics:
1. Modify the operating system.
2. Implement a form of TLS that is compatible with the OS, but doesn't require modifying the OS.

In kernel mode, most operating systems have some concept of a thread ID.  Such a thread ID can be used to construct a global associative container correlating thread ID to some arbitrary state.  A map like this would further degrade performance in the `throw` code path, and introduce an additional point of failure, but it could be made conforming.  No known runtime implementation takes this approach though.

[[Baker2017]] and [[Quinn2016]] have demonstrated working C++ exceptions in the Windows kernel, but both of those were using hypervisors, and involved little interaction with the Windows kernel.

[[ntke_cpprtl]] does not appear to support `std::uncaught_exceptions` in the Windows kernel.

[[Gylfason2004]] is able to support full C++ exceptions in a modified Linux kernel.  The modification adds a small size overhead to every kernel mode thread, even those that do not use C++.

In each of these cases, a very useful subset of C++ exceptions is still available, even without changing the kernel code or re-implementing TLS.  Users can `throw` and `catch` arbitrary types, while invoking the correct destructors along the way.

Bare metal environments {#baremetal}
------------------------------------
Note: Bare metal environments are often associated with real-time applications and microcontrollers.  While this is often the case, bare metal challenges are also an issue for the early stages of a server, desktop, or mobile OS boot process.  These environments have ample RAM and storage space, and often have multiple hardware threads available.

Some aspects of table-based exception handling require storage that is local to a thread ([[#tls]]).  Compilers and library runtimes typically implement this in terms of thread local storage.  Thread local storage is traditionally an operating system facility.  Implementing thread local storage requires agreement between the operating environment, the compiler, the linker, and the runtime.  Each of these pieces may be implemented by different vendors.

The allocation of the exception object can be an issue in bare metal environments ([[#eh_alloc]]).

None of these technical concerns are an issue for error codes.

If the operating environment and the toolchain do not have a working, vendor supplied implementation of exceptions, then many programmers will choose to use error codes, rather than fix the toolchain and operating environment.

GPU and accelerator environments {#gpus}
-----------------------------
TODO: Get Olivier to review this. 

Flow-control based error handling inhibits the most valuable optimization in that GPU domain because it introduces divergent code flow.  I define flow-control based error handling as any error handling that changes the main sequence of instructions executed.  This covers exception-based programming models, error code based programming models, and even things like `expected`.  Tools like floating-point NaN propagation are an alternate, but unpopular way to propagate errors in a way that doesn't suffer from divergent control flow.

Potentially divergent control flow is substantially slower than coherent control flow.  A different set of instructions needs to be generated to handle potentially divergent control flow.  This extra code often involves setting up execution masks and dealing with their overhead.  Distant, non-call based control transfers (e.g. `setjmp`) have additional implementation challenges in some existing hardware.  In addition, if any threads take the sad path, performance is negatively affected for threads on the happy path.

By default, in C++, every function has the potential to throw and introduce an extra control flow edge into the caller.  This default makes it easy to accidentally introduce divergent code flow into code that has no need of an error path.  The default adds verbosity to the common case in GPU programming.

Direct FPGA environments {#fpgas}
-----------------------------
TODO: Get Ronan Keryell to review this

I use the term "direct FPGA" to mean that C++ code is synthesized into a netlist.  This is in opposition to use cases that have a CPU or microcontroller programmed into the FPGA fabric, with a program running on the CPU or microcontroller.

Many constructs in C and C++ can be converted into an electronic circuit in a straightforward way.  Indirect calls, through function pointers, virtual calls, and table-based stack unwinding, are all challenges.  One does not simply "jump" from one portion of an FPGA to another portion of the FPGA that has the logic that needs to run.  Tackling this challenge is an ongoing area of research.

FPGAs are heavily space constrained, similar to microcontrollers ([[#microcontrollers]]).  Code size is even more constrained though, as code goes into FPGA gates, and FPGA gates are significantly more expensive than RAM.

Non-critical failure performance {#unnoticed_fail}
-------------------------------------
There are a great many applications where the performance on the failure path is of low importance.

In many interactive applications, a user interaction will often cause some operation to take place, and if that operation fails, then a dialog, or some other kind of user interaction is shown (e.g. opening a document of some kind).  The value of the program is the same whether the dialog shows up in 1 millisecond or 50 milliseconds.

There are non-interactive applications that care a great deal about latency on the success path ([[#cant_go_fast_enough]]), but don't care about performance on the failure path.  In the failure cases, no transaction needs to happen, so it is acceptable to take a longer amount of time, so long as the latency of the next success path operation is unaffected.

There are non-interactive simulation and modeling applications (e.g. high-performance computing) where no exceptions happen during a successful simulation, and an exception is only thrown during an unsuccessful run.  When these exceptions happen, it normally indicates some kind of failure that requires human intervention, like adjusting the starting parameters, or freeing up hard disk space, or plugging a network cable back in.  A few extra milliseconds to account for stack unwinding is perfectly acceptable in these circumstances.

Throughput applications {#throughput_apps}
-----------------------------------------
TODO: anyone have a better "errors are random" example than dropped network packets?

In some applications, failure is rare and largely random.  Suppose you have an application that is sending terabytes of information over an unreliable network.  Suppose that over a long enough time period, only 1 in 100,000 packets are dropped.  In such an application, momentary failure is expected to happen on occasion, but success is by far the most common case.  In such an application, table-based exceptions could provide better throughput than error codes, despite the fact that the sad path for table-based exceptions is so slow.

Note that there are substantial caveats to the suitability of table-based exceptions in this path.  The failures need to be safe to model as uniformly distributed failures over realistic application run times.  This is a dubious claim for the networking example above.  In real networks, packet loss isn't entirely random.  If packet X was dropped, packet X+1 is substantially more likely to be dropped than a packet chosen at random.  This clustering of errors may cause a cascading series of failures that a single random dropped packet would not cause.  Packet loss can also be directly instigated by a malicious actor.  An attacker could leverage the performance difference in the sad path vs. the happy path, and that difference could lead to a denial-of-service attack.

Performance as a competitive advantage {#cant_go_fast_enough}
-------------------------------------------------------------
The value of a performance gain varies across domains and applications.  In some applications, extra performance gains past a certain threshold are largely meaningless.  Once the application has reached it's performance goal, it is going "fast enough".  Some applications and domains either have no such upper limit, or the limit is sufficiently distant from the current state of the art to be unreachable.

Latency sensitive financial operations are an example of an application where all performance gains are beneficial.  In some of these operations, the absolute performance doesn't matter.  What matters is whether you are faster than your competitor.  The performance on the sad path doesn't have these same constraints.  This usually means that programmers are willing to make substantial sacrifices to sad path performance in order to get any benefit to happy path performance.

Table-based exceptions provide such a trade-off.  Extraordinary effort is taken on behalf of the implementation to ensure that the happy path is as fast as can be, at the expense of a slow sad path.  This is a good trade-off for applications that "can't go fast enough".

Other implementation approaches to exceptions {#other_approaches}
---------------------------------------------------
There are two major strategies to implementing standards conforming C++ exceptions: [=table-based exceptions=] and [=frame-tracking exceptions=].  There are multiple implementations and ABIs of each of these strategies in use today:
* Table-based exceptions
    * GCC, Clang, and Intel implementations using the Itanium ABI [[ItaniumEHABI]], notably on x86_64
    * GCC and Clang implementations using the EHABI, notably on some ARM platforms
    * Four different iterations of exceptions on Visual Studio x86_64
* Frame-tracking
    * Various implementations of "SJLJ" exceptions (setjmp / longjmp), most commonly used on mingw32
    * Three iterations of exceptions on Visual Studio x86

In general, the market has converged on table-based exceptions, and the remaining frame-tracking implementations exist largely for compatibility reasons.  The dominant voices in the C++ community and market prefer the inherent trade offs of table-based exceptions to those of frame-tracking.  Frame-tracking looks really bad when comparing Visual Studio's x86 implementation (frame-tracking) to Visual Studio's x86_64 implementation (table-based).  [[P1886R0]] Shows the x86_64 implementation having faster happy path and sad path execution times.  [[P1640R1]] show higher incremental error-neutral and error handling space costs for the x86 implementation.

However, there are other approaches to frame tracking.  [[Renwick2019]] discusses a frame-tracking implementation that performs orders of magnitude better than table-based exceptions in the sad path, while having very similar performance on the happy path.  The implementation is also able to avoid pulling in heavy-weight runtime support.  The improved sad path execution time is ideal for systems that are concerned about worst case execution time.

Exception handling allocation {#eh_alloc}
----------------------------------------
The Itanium ABI requires thrown exception objects to be placed in a non-local location, frequently the heap.  Stateless, well-known exception types can potentially be stored and thrown as global singletons.  Heap allocation is challenging in environments that do not support the heap, or do not have a single appropriate approach for allocating from the heap.  In order to mitigate the risk of running out of memory during an exception throw, some implementations have a fall-back buffer.  This fall-back buffer is often too expensive in memory constrained environments.

Other ABIs can store thrown exceptions in other ways, but this storage is either forced to be a fixed size, or dynamic in some way or another.  In the Microsoft implementations (x86 and x86-64), a dynamic stack allocation is made, and the thrown exception is stored there.  The Microsoft x86-64 implementation of exceptions consumes roughly 9KB of stack in order to rethrow an exception.  9KB is larger that the entire stack on some microcontroller environments.  A space constrained implementation would need to be more stack-space efficient than 9KB per rethrow.

Exception handling and storage that is local to a thread {#tls}
--------------------------------------------------------------
`std::uncaught_exceptions`, `throw;`, and `std::current_exception` are all "non-local" facilities that impose additional requirements on exception handling implementations beyond the basic, `throw`, `catch`, and destructor requirements.  Each of the non-local facilities takes no parameters, but still yield state about the current state of the exception handling machinery.  The common way to implement these non-local facilities is with thread-local storage.  `throw` will store information in a thread-local variable, the non-local facilities will use the data, and `catch` will clean it up.  Users generally expect to be able to query this information, even when calling across non-C++ languages.  For example, if a destructor calls into a C function, and the C function calls into another C++ free function, the free function is expected to be able to get valid results from `std::uncaught_exceptions`.

Thread local storage is usually implemented in terms of a reserved register that points to a thread control block.  The thread control block contains information such as the thread ID, a pointer to the base of the stack, and pointer(s) to thread local storage.  The `thread_local` keyword in particular usually requires special linker and OS support in order to make it efficient.  An inefficient implementation of the `thread_local` keyword can use a locked map with the thread ID as a key.

If the implementation is restricted to a single thread, then a global can be used.  If the implementation has substantial control over the ABI and calling conventions of the system, then a register can be reserved for passing around the exception state.  A hidden parameter can be used to pass along exception state, but the state needs to be passed to _all_ functions, even destructors and `noexcept` functions, as those functions can (and do) use `std::uncaught_exceptions`, `throw;` and `std::current_exception`.  Note that the hidden parameter and exception state register approaches are isomorphic to thread local storage.  Also note that these end up being platform requirements, and not just C++ requirements.  In order to support the cross-language use cases, these hidden parameters and reserved registers must be respected by all languages in use, and not just C++.  In these case, the platform ABI imposes a cost on all code, even non-C++ code, and even when no C++ code is being invoked at the time.

None of the major desktop operating systems on the market today support arbitrary thread local storage in the kernel (Windows, Linux, OSX, BSD).  All have a thread ID available though, so inefficient `thread_local` storage could be implemented.  In the embedded space, most of the off-the-shelf RTOS's do not support the `thread_local` keyword, and do not implement the OS side of the complicated hand shake that the compilers, linkers, and runtimes expect.  Embedded RTOS's usually do have thread IDs available, and they also frequently support adding particular items to thread local storage, such as `errno`.

Are fast exceptions important enough? {#dubious_business_value}
----------------------------------------------
Suppose implementers research ways to make their C++ exception implementation faster on the sad path, and suppose they wildly succeed.  Somehow, the implementers produced an implementation that has the same happy path characteristics as today's implementations, but is only twice as slow as error codes on the sad path, rather than more than 100 times slower [[P1886R0]]. According to [[SC++F_2020]], this would, at best, allow 25% of current non-exception users to start using exceptions.  The other non-users of exceptions are blocked on other reasons.  Some of the users are based on technical reasons, like space overhead.  Others are non-users for more philosophical reasons, such as a dislike of invisible propagation.

When an implementer works on any feature, including exceptions, there is an opportunity cost.  Is working on exceptions more valuable than squeezing half a percent more throughput out of the automatic vectorizer?  Is it more valuable than adding another warning to the front end?  One way that implementers gauge how important a change is is by looking at quantity of bug reports.  A search for "exception slow" on the GCC bug tracker has 21 hits, but only 2 of those (bugs [92823](https://gcc.gnu.org/bugzilla/show_bug.cgi?id=92823) and [68606](https://gcc.gnu.org/bugzilla/show_bug.cgi?id=68606) )  are really C++ exception handling related.  On the LLVM bug tracker, there are 18 hits, but again, only 2 for C++ exception handling (bugs [1916](https://bugs.llvm.org/show_bug.cgi?id=1916) and [17467](https://bugs.llvm.org/show_bug.cgi?id=17467) ) .  Users have been trained to not put exceptions in performance critical areas, so users rarely complain about exception performance because there aren't exceptions in their performance critical areas.

Now, suppose that wg21 does something to exceptions to make them more appealing to users that do not currently use exceptions.  Would we end up compromising the design of C++ to try to satisfy a group of developers that won't ever be satisfied?  How many developers do we need to migrate to consider our efforts a success?

The N+1 problem {#n_plus_one}
----------------------------
There is no shortage of error handling mechanisms in the standard library and in the wild today.  The "N" is already a large number.  The C portions of the standard library use integer error codes and `errno`.  `qsort` and `bsearch` take callbacks, and those callbacks are allowed to throw exceptions through `qsort` and `bsearch`.  In the filesystem library, both `std::exception` based exceptions and `std::error_code` based error codes are used.  

Even if the C++ standard does not add new error handling mechanisms, the community will likely do so.  `expected`, `outcome`, and `LEAF` are all community libraries dealing with error handling.  More will continue to be authored.

It is common place for users to need to translate the results of various error handling mechanisms into the error handling mechanism that their program uses.  This happens routinely when a C++ program using exceptions calls into a C library that uses callbacks and error codes.  The translation is not difficult, though it is verbose and error prone (lots of `try` / `catch` blocks and error testing `if` statements).

Creating a new error handling mechanism does not make the old mechanisms go away.  If you had N mechanisms before, a new mechanism, no matter how superior a choice, will leave you with N+1 mechanisms.  The existence of `std::error_code` in C++11 did not make exceptions, `errno`, or integer error codes leave the ecosystem.  Each of these error mechanisms is likely to remain in use for decades to come.  Similarly, P0709 exceptions, [[P1095]] failures, and `expected` are unlikely to make old error handling strategies disappear, even if these new strategies become the most common error handling strategies.

A new error handling mechanism could change how we teach error handling, and how we write error handling in new code.  This has happened in the past, and could happen again.  There is very little educational effort spent on `errno` best practices, and very little new C++ code is written with `errno` as the primary error handling mechanism.  The main interaction with `errno` is in handling the errors and translating them to newer mechanisms.  A new error handling mechanism can aspire to replace other mechanisms as well as `errno` has been replaced.

Local vs. global trade-offs with error handling {#global_decision}
------------------
There are cases where there are different needs for error handling performance within the same program, translation unit, or even function.  Users cannot make a local decision on whether exceptions prefer happy path performance or worst-case-execution-time performance.  Users can make local choices as to whether to use exceptions or not, with the assumption that exceptions prefer happy path performance.  Choosing something other than exceptions will often lead to impoverished syntax.

Imagine a server application that can normally handle 10,000 concurrent clients.  It has a function that looks up a trusted string using an integer key from an untrusted source.  During normal usage with no malicious users, the untrusted ID will always correspond to an item in the map.  A malicious user can trivially choose a number that is not in the map.  A naive implementation may look like this:
```
const std::map<int, std::string> global_map = { /*elements*/ };
std::string get_name(int untrusted_id) {
    return global_map.at(untrusted_id);
}
```
There are two main points of failure in get_name.  The lookup could fail, or the copy construction of `std::string` could fail.

Since these strings are known at compile time, it would be reasonable to assume that they are of a relatively small size (i.e. not megabytes or larger), and therefore, the copy construction of the string will almost never fail.  Table-based exceptions seem reasonable as a way to handle the potential `std::string` failures.  

The lookup failure is more problematic.  Failure to find the item will trigger an exception.  Semantically, an exception is a reasonable thing to do here, as this is an error path.  Syntactically, an exception is reasonable, as now the calling code doesn't need to worry about whether the return value exists or not.  However, if the underlying implementation is a table-based exception implementation, then this exception will consume a large amount of CPU, and such CPU usage can be used as part of a denial-of-service attack.  The server that could normally handle 10,000 concurrent clients may now only be able to deal with 5,000 malicious requests.

An alternative implementation may use `std::optional` to represent a possible failure:
```
std::optional<std::string> get_opt_name(int untrusted_id) {
    auto it = global_map.find(untrusted_id);
    if(it == global_map.end())
        return {};
    return it->second;
}
```
This code has similar performance for both successful and failed lookups, which is desirable.  However, it takes more code to express this, and the usage of this function is also more complicated. `auto name = get_opt_name(id); name->c_str();` compiles, but invokes undefined behavior if the item isn't present.  We have gained performance, but lost notational convenience.  Currently, if users want portable worst-case-execution-time performance, they lose notational convenience.  There is no way to portably express that a program should prefer happy path execution time in its error handling code.

Exception handling overhead is difficult to avoid {#using_is_easy}
----------------------------------------------------------------
When a compiler sees a function call, and the function call is not marked `noexcept`, the safe thing for the compiler to do is to generate exception bookkeeping code and data structures.  If the compiler has suitable visibility into the function and can prove that it won't throw, then the compiler can generate less bookkeeping.  In many applications, it is difficult or impossible to get global visibility in order to avoid bookkeeping.  It is difficult to analyze code in pre-built static libraries.  It is difficult to determine, at compile time, the target of indirect calls through virtual functions and function pointers to see if all possible targets avoid exceptional paths.  It is generally impossible for the compiler to infer anything about the exception status of code in a dynamic library if it isn't explicitly marked as noexcept.  This means that the compiler usually needs to do the safe thing, and include exception handling machinery and bookkeeping for large portions of the program.  This has a size cost.  It also introduces places where the compiler believes there are extra code flow paths where they may not exist, and those extra code flow paths can inhibit optimizations.

This is particularly concerning when calling into non-C++ code.  Non-C++ code is unlikely to throw exceptions, and it is unlikely to mark such functions as noexcept.  The C++ compiler does not know that though, and generates conservative code as a result.

Tooling analysis of sad paths {#sad_path_analysis}
-----------------------------------------------
TODO: Get this section reviewed by full time static analyzer folks.  Aaron Ballman, Tom Honerman

There is a spectrum of difficulty in dealing with the various error handling schemes, with integer error codes on one side, and dynamically-typed exceptions on the other.  Error codes with dynamic aspects and statically-typed exceptions (i.e. throwing and catching a non-polymorphic type) lie somewhere in between these two extremes.

Static analyzers routinely analyze code like the following:
```
int compute_velocity(const point_container &points);
int fetch_speed(const simulation_parameters *params) {
	point_container points = params->points;
	int vel = compute_velocity(points);
	if(vel < 0)
		return -vel;
	return vel;
}
```
Static analyzers can reason about the cases where `vel` is positive or negative.  They can deal with multiple return statements in the same function.  They can deal with destructors.

Programs using integer error codes will have very similar branching structures.  In these programs, the reasoning needed for high quality diagnostics, stack usage, or worst case execution time is the same for both the happy path and the sad path.

There are constructs that provide more difficulty, and provide more opportunities for static analyzers to differentiate themselves.  Indirect calls (whether through function pointers, virtual calls, or otherwise) are challenging.  Mutations to non-local state are difficult.  For integer error codes, these are aspects that are equally difficult in the happy path and the sad path.

For programs using dynamically-typed exceptions, analysis is much harder.  Determining which catch statements can handle a given exception requires an indirect call.  Determining which catch statements might be invoked requires crossing any indirect calls in the static call graph.  For performance analysis, table-based exceptions fare poorly, as the performance of the exception handling mechanism depends on the size of the table, the complexity of the inheritance hierarchies, and in many cases, the performance characteristics of the system allocator.  These are all things that can be analyzed, but they are static analyzer requirements that aren't necessarily present on the happy path.


Definitions {#definitions}
============
<dfn>Happy path</dfn> The code path where no errors occur.

<dfn>Sad path</dfn> The code path where an error occurs.

<dfn>Program-recoverable</dfn> The ability to recover from a failure or error without terminating the program.  Note that there exist systems of programs where recovery of the system involves terminating and restarting constituent programs.  Errors and failures leading to this kind of termination and restarting are not program-recoverable.

<dfn>Table-based exceptions</dfn> An implementation strategy for exceptions where the program counter is used as an index into a table of exception unwinding actions.  Table-based exceptions typically have very low (possibly zero) time overhead on the happy path, at the cost of very slow sad path execution.

<dfn>Frame-tracking exceptions</dfn> An implementation strategy for exceptions where book-keeping information is tracked during normal program execution, so that it can be provided and used during exception unwinding.  Frame-tracking exceptions have some unavoidable time overhead on the happy path, with the benefit of potentially faster sad paths, as well as more straightforward implementations.

<dfn>Failure flag</dfn> The one bit of information that indicates whether a function has failed.  This bit may be implicit based off of the static control flow in the program, as is the case with exceptions.[[Dotchevski]]

<dfn>Failure classification</dfn> The failure classification indicates the category of an error so that it can be handled in aggregate.  Examples are timeout errors and file system failures.  Some error handling mechanisms allow for rich classification (e.g. C++ exceptions with multiple inheritance based categories).  Some error handling mechanisms have no built in form of classification, and implicitly place all errors in the same category (e.g. errno).  Other classification approaches exist between and beyond these extremes.

<dfn>Failure payload</dfn> Any additional information beyond the failure flag that is carried with an error.  This payload may be of a fixed size, or it may be completely arbitrary.

<dfn>Unwind</dfn> The action of performing cleanup and skipping happy path code that occurs after an error is raised.  Unwinding stops when an error handler has been found and executed.  This process can be automatic, as is the case with exceptions, or manual, as is the case with error codes combined with early returns.

Acknowledgments {#ack}
======================
Thank you to Emil Dotchevski, for providing valuable review feedback.

<pre class=biblio>
{
    "P0323": {
        "authors": ["JF Bastien", "Vicente Botet"],
        "href": "https://wg21.link/P0323R9",
        "title": "std::expected"
    },
    "P0709": {
        "authors": ["Herb Sutter"],
        "href": "https://wg21.link/P0709R4",
        "title": "Zero-overhead deterministic exceptions: Throwing values"
    },
    "P1095": {
        "authors": ["Niall Douglas"],
        "href": "https://wg21.link/P1095R0",
        "title": "Zero overhead deterministic failure - A unified mechanism for C and C++"
    },
    "P1886R0": {
        "authors": ["Ben Craig"],
        "title": "Error speed benchmarking",
        "href": "https://wg21.link/P1886R0"
    },
    "P1640R1": {
        "authors": ["Ben Craig"],
        "title": "Error size benchmarking: Redux",
        "href": "https://wg21.link/P1640R1"
    },
    "Glisse2013": {
        "authors": ["Marc Glisse"],
        "title": "Remove throw when we can see the catch",
        "href": "https://bugs.llvm.org/show_bug.cgi?id=17467"
    },
    "P1676R0": {
        "authors": ["Gor Nishanov"],
        "title": "C++ Exception Optimizations. An experiment.",
        "href": "https://wg21.link/P1676R0"
    },
    "P1947R0": {
        "authors": ["Bjarne Stroustrup"],
        "title": "C++ exceptions and alternatives",
        "href": "https://wg21.link/P1947R0"
    },
    "Gylfason2004": {
        "authors": ["Halldór Ísak Gylfason", "Gísli Hjálmtýsson"],
        "title": "Exceptional Kernel -- Using C++ exceptions in the Linux kernel",
        "href": "http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.100.7504"
    },
    "Baker2017": {
        "authors": ["Billy Baker"],
        "title": "Almost Unlimited Modern C++ in Kernel-Mode Applications",
        "href": "https://www.youtube.com/watch?v=4AMhgkLjVHM"
    },
    "Quinn2016": {
        "authors": ["Rian Quinn"],
        "title": "Making C++ and the STL Work in the Linux / Windows Kernels",
        "href": "https://www.youtube.com/watch?v=uQSQy-7lveQ"
    },
    "ntke_cpprtl": {
        "title": "C++ RTL for NT ke-mode drivers",
        "href": "https://svn.riouxsvn.com/prj_ntke_cpprtl/trunk/"
    },
    "Renwick2019": {
        "authors": ["James Renwick", "Tom Spink", "Björn Franke"],
        "title": "Low-cost deterministic C++ exceptions for embedded systems",
        "href": "https://www.research.ed.ac.uk/portal/en/publications/lowcost-deterministic-c-exceptions-for-embedded-systems(2cfc59d5-fa95-45e0-83b2-46e51098cf1f).html"
    },
    "Cargill1994": {
        "authors": ["Tom Cargill"],
        "title": "Exception Handling: A False Sense of Security",
        "href": "http://ptgmedia.pearsoncmg.com/imprint_downloads/informit/aw/meyerscddemo/DEMO/MAGAZINE/CA_FRAME.HTM"
    },
    "MoFH4": {
        "authors": ["Modi Mo"],
        "href": "https://devblogs.microsoft.com/cppblog/making-cpp-exception-handling-smaller-x64/",
        "title": "Making C++ Exception Handling Smaller On x64"
    },
    "ItaniumEHABI": {
        "title": "Itanium C++ ABI: Exception Handling",
        "href": "https://itanium-cxx-abi.github.io/cxx-abi/abi-eh.html"
    },
    "SC++F_2018": {
        "authors": ["Standard C++ Foundation"],
        "title": "Results summary: C++ Foundation Developer Survey 'Lite', 2018-02",
        "href": "https://isocpp.org/blog/2018/03/results-summary-cpp-foundation-developer-survey-lite-2018-02"
    },
    "SC++F_2019": {
        "authors": ["Standard C++ Foundation"],
        "title": "Results summary: 2019 Global Developer Survey 'Lite'",
        "href": "https://isocpp.org/blog/2019/05/results-summary-2019-global-developer-survey-lite"
    },
    "SC++F_2020": {
        "authors": ["Standard C++ Foundation"],
        "title": "Results summary: 2020 Global Developer Survey 'Lite'",
        "href": "https://isocpp.org/files/papers/CppDevSurvey-2020-04-summary.pdf"
    },
    "DE1994": {
        "authors": ["Bjarne Stroustrup"],
        "title": "The Design and Evolution of C++"
    },
    "Dotchevski": {
        "authors": ["Emil Dotchevski"],
        "title": "Error Handling Principles and Practices",
        "href": "https://github.com/zajo/leaf/blob/master/doc/whitepaper.md"
    },
    "LEAF": {
        "authors": ["Emil Dotchevski"],
        "title": "LEAF: Lightweight Error Augmentation Framework",
        "href": "https://zajo.github.io/leaf/"
    }
}
</pre>
