<pre class='metadata'>
Title: Make Exceptions and Company Optional for Freestanding Implementations
Shortname: D0000
Revision: 0
Audience: SG14, EWG
Status: D
Group: WG21
URL: http://example.com/url-this-spec-will-live-at
!Source: <a href="https://github.com/ben-craig/freestanding_proposal/blob/master/core/optional_exceptions.bs">github.com/ben-craig/freestanding_proposal/blob/master/core/optional_exceptions.bs</a>
Editor: Ben Craig &lt;ben dot craig at gmail dot com&gt;
Abstract: Making core language features (like exceptions) optional in freestanding mode if they have an OS dependency or incur space overhead.
Markup Shorthands: markdown yes
</pre>

Introduction {#intro}
=====================

Introduction here.
Something about Embedded C++ and the Embedded Template Library


Features going optional {#features}
===================================
The following applies only to freestanding mode.  Hosted mode will remain unchanged.

Exceptions {#exceptions}
------------------------
This section applies to "dynamic" exceptions.  In other words, the exceptions we have had since C++98.  [[P0709]] could add "static" exceptions.  I am keeping static exceptions in mind with this design, but I'm not providing any wording against that proposal.

### Why make this optional? ### {#exception_why}
Kernel and embedded environments can't universally afford exceptions.  Throwing an exception requires a heap allocation on the Itanium ABI, and a large stack allocation in the Microsoft ABI, neither of which are suitable in kernel and embedded environments.  Throwing an exception requires TLS ([[#tls]]) in order to propagate the number of uncaught exceptions.  Windows, Linux, Mac, and FreeBSD don't allow drivers to store arbitrary TLS data, and they don't have any special handling for C++ specific TLS requirements, like the number of uncaught exceptions.

Even when exceptions aren't thrown, there is a large space cost.  Table based exception costs grows roughly in proportion to the size and complexity of the program, and not in the number of `throw` sites, `catch` sites, or frames traversed in an exception `throw`.  Since table based exception costs grows with program size, rather than how much it is used, it is not zero overhead.  `setjmp` / `longjmp` exception size costs are similar in these regards.

See [[P0709]] for further discussion on the problems with exceptions.

### What isn't changing? ### {#exception_same}
`try` and `catch` are both still allowed.  Compilers should treat `catch` blocks as unreachable code.  `try` and `catch` blocks are allowed so that exception neutral code can be shared between freestanding and hosted implementations without requiring preprocessor hackery.

### What am I changing (and why)? ### {#exception_what}
`throw` expressions with operands are ill formed if exception support is not present.  When exception support isn't present, we can't reliably unwind the stack, so we should error when that is requested.

Evaluating a `throw` expression with no operands (a "rethrow") is undefined behavior.  We allow the programmer to compile with a rethrow to allow exception neutral code to be shared between freestanding and hosted implementations, but the rethrow shouldn't ever be evaluated, since we shouldn't be able to get into a `catch` block.  This behavior is different from the current behavior though, as a rethrow without an active exception currently calls `std::terminate`.  I don't call `std::terminate`, as `std::terminate` relies on the global terminate handler, and freestanding doesn't want to pay the cost of synchronizing the global terminate handler.

When a function without a `noexcept` specification is passed to a `noexcept` expression, `noexcept` will return true if exception support is not present.  This will speed up operations like `move_if_noexcept` and containers with strong exception guarantees.  This also differs somewhat from existing practices.  Visual Studio, clang, and gcc do not currently adjust the value of `noexcept` when exceptions are off.  The Intel compiler (with EDG frontend) makes the `noexcept` operator unconditionally return true when exceptions are turned off.  In addition, Visual Studio has a compiler mode, /EHsc, that takes `extern "C"` functions and makes them `noexcept`.  Note that this approach leaves the door open for static exceptions to use `noexcept`.

`noexcept(false)` code should be treated with suspicion.  This isn't normative, but it would be a useful place for compilers to warn.

The `<exception>` header is not required to be present.  Note that this removes `std::terminate` and `uncaught_exceptions`.

`catch` blocks are treated the same as an `if constexpr(false)` block.  This is to allow some trivial exception translation to continue compiling.  TODO: what if the `catch` block translates from one exception to another, but uses a helper function to do so?  Maybe make `throw` UB?

RTTI {#rtti}
------------
### What am I changing? ### {#rtti_what}

### Why? ### {#rtti_why}
Potential change in ABI

Default heap storage {#heap}
----------------------------
### What am I changing? ### {#heap_what}

### Why? ### {#heap_why}
Related, virtual destructors

Thread local storage {#tls}
---------------------------
### What am I changing? ### {#tls_what}

### Why? ### {#tls_why}

Floating point {#float}
-----------------------
### What am I changing? ### {#float_what}

### Why? ### {#float_why}

Program startup and teardown {#startup_teardown}
------------------------------------------------
### What am I changing? ### {#startup_teardown_what}

### Why? ### {#startup_teardown_why}

Function local statics {#function_statics}
------------------------------------------
### What am I changing? ### {#function_statics_what}

### Why? ### {#function_statics_why}

Locked atomics {#locked_atomics}
--------------------------------
### What am I changing? ### {#locked_atomics_what}

### Why? ### {#locked_atomics_why}

Common QoI issues {#qoi}
=================
Pure virtual functions


<pre class=biblio>
{
    "P0709": {
        "authors": ["Herb Sutter"],
        "href": "http://wg21.link/P0709",
        "title": "Zero-overhead deterministic exceptions: Throw values"
    }
}
</pre>
